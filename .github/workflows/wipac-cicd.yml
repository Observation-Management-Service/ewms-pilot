name: wipac ci/cd

on:
  push:
    branches:
      - '**'
    tags-ignore:
      - '**'

# these tests can many minutes -- comment/uncomment block on a per-PR basis
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  # don't cancel on main/master/default
  cancel-in-progress: ${{ format('refs/heads/{0}', github.event.repository.default_branch) != github.ref }}

env:
  # url pointing to remote helper scripts — versioned!
  CI_SCRIPT_URL_INSTALL_APPTAINER: https://raw.githubusercontent.com/WIPACrepo/wipac-dev-tools/refs/heads/resource-scripts/resources/apptainer/install-apptainer.sh
  CI_SCRIPT_URL_DOOD_RUN: https://raw.githubusercontent.com/WIPACrepo/wipac-dev-tools/refs/heads/resource-scripts/resources/docker/run-docker-outside-of-docker.sh
  #
  # a special network set up so docker scanner clients (inside of docker pilots) can talk to the mq broker
  DOOD_NETWORK: mynet
  #
  RABBITMQ_IMAGE_TAG: bitnamilegacy/rabbitmq:3.13.5
  PULSAR_IMAGE_TAG: apachepulsar/pulsar:2.6.0
  NATS_IMAGE_TAG: nats:2.10.18
  #
  SORTED_LIST_OF_TESTS_FILE: list-of-tests-sorted.txt
  #
  BROKER_CONTAINER_NAME: thebroker
  #
  EWMS_PILOT_TIMEOUT_INCOMING: 1
  EWMS_PILOT_TIMEOUT_OUTGOING: 1
  EWMS_PILOT_KEEP_ALL_TASK_FILES: True
  #
  _EWMS_PILOT_APPTAINER_IMAGE_DIRECTORY_MUST_BE_PRESENT: False  # allow real-time conversion
  #
  DOCKER_IMAGE_NAME: pilot/local


jobs:

  py-versions:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.versions.outputs.matrix }}
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.sha }}  # lock to triggered commit (github.ref is dynamic)
      - id: versions
        uses: WIPACrepo/wipac-dev-py-versions-action@v2.7


  #############################################################################
  # LINTERS
  #############################################################################

  flake8:
    needs: [ py-versions ]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        py3: ${{ fromJSON(needs.py-versions.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.sha }}  # lock to triggered commit (github.ref is dynamic)
      - uses: actions/setup-python@v6
        with:
          python-version: ${{ matrix.py3 }}
      - uses: WIPACrepo/wipac-dev-flake8-action@v1.3
        with:
          max-complexity: 12  # ideal is ~10-15

  mypy:
    needs: [ py-versions ]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        py3: ${{ fromJSON(needs.py-versions.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.sha }}  # lock to triggered commit (github.ref is dynamic)
          fetch-depth: 0  # setuptools-scm needs to access git tags
      - uses: actions/setup-python@v6
        with:
          python-version: ${{ matrix.py3 }}
      - uses: WIPACrepo/wipac-dev-mypy-action@v2.0


  #############################################################################
  # PACKAGING
  #############################################################################

  py-setup:
    if: ${{ github.actor != 'dependabot[bot]' }} # dependabot cannot access PAT
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
          ref: ${{ github.ref }}  # dont lock to sha (action needs to push)
      - uses: WIPACrepo/wipac-dev-py-setup-action@v5.8
        with:
          mode: PACKAGING
          python_min: 3.12
          keywords_comma: "pilot, task pilot, Observation Management Service, Event Workflow Management System, EWMS, message passing, MQ"
          auto_mypy_option: True

  py-dependencies:
    needs: [ py-versions ]
    runs-on: ubuntu-latest
    concurrency: # use a special concurrency here so we don't keep building and re-building images
      group: ${{ github.workflow }}-${{ github.ref }}-${{ github.job }}
      # don't cancel on main/default
      cancel-in-progress: ${{ format('refs/heads/{0}', github.event.repository.default_branch) != github.ref }}
    steps:
      # optimization: ask the action if it would proceed before building our expensive images
      - uses: WIPACrepo/wipac-dev-py-dependencies-action@v3.4
        id: pydep-precheck
        with:
          only_precheck: true

      # pre-check passed, so proceed...
      - if: ${{ steps.pydep-precheck.outputs.do_generation == 'true' }}
        uses: actions/checkout@v5
        with:
          ref: ${{ github.sha }}  # lock to triggered commit (github.ref is dynamic)
          fetch-depth: 0  # setuptools-scm needs to access git tags
      - if: ${{ steps.pydep-precheck.outputs.do_generation == 'true' }}
        name: build all images
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          set -x
          
          mkdir docker-build-logs/ && trap 'rm -rf docker-build-logs/' EXIT
          
          # first, build the vanilla/default image
          pidlist=""
          docker build --tag "default:py-dep-this" . \
              >> docker-build-logs/default.docker-build.out 2>&1 & pidlist="$pidlist $!"
          
          # build all dockerfiles -- all in background/parallel
          for py in $(echo ${{ needs.py-versions.outputs.matrix }} | sed 's/[][]//g; s/,/ /g'); do
              docker pull python:$py  # pre-pull to speed up dependent images
              for flavor in rabbitmq pulsar nats; do
                    # normal
                    tag="$py-$flavor:py-dep-this"
                    docker build --tag $tag \
                        --build-arg="PYTHON=$py" --build-arg="FLAVOR=$flavor" \
                        . \
                        >> docker-build-logs/$tag.docker-build.out 2>&1 & pidlist="$pidlist $!"
                    sleep .1  # little sleep to help logs
                    # another with 'tests'
                    tag="$py-$flavor-test:py-dep-this"
                    docker build --tag $tag \
                        --build-arg="PYTHON=$py" --build-arg="FLAVOR=$flavor,test" \
                        . \
                        >> docker-build-logs/$tag.docker-build.out 2>&1 & pidlist="$pidlist $!"
                    sleep .1  # little sleep to help logs
              done
          done
          
          # wait for all them
          for pid in $pidlist; do
              sleep .1  # little sleep to help logs
              echo "waiting for $pid..."
              if ! wait -n $pid; then
                  sleep 5  # may need to wait for file to be written
                  kill $pidlist 2>/dev/null
                  sleep 5
                  more docker-build-logs/* | cat  # cats with filenames (delimited by :::::::)
                  exit 1
              fi
          done
          
          docker system prune --force  # save disk space
      - if: ${{ steps.pydep-precheck.outputs.do_generation == 'true' }}
        uses: WIPACrepo/wipac-dev-py-dependencies-action@v3.4


  ############################################################################
  # TESTS
  #############################################################################

  test-build-docker:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.sha }}  # lock to triggered commit (github.ref is dynamic)
          fetch-depth: 0  # setuptools-scm needs to access git tags
      - uses: docker/setup-buildx-action@v3
      - uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          cache-from: type=gha
          cache-to: type=gha,mode=min
          tags: ${{ env.DOCKER_IMAGE_NAME }}:local

  vanilla-run:
    runs-on: ubuntu-latest
    env:
      EWMS_PILOT_QUEUE_INCOMING_BROKER_TYPE: rabbitmq
      EWMS_PILOT_QUEUE_OUTGOING_BROKER_TYPE: rabbitmq
      EWMS_PILOT_QUEUE_INCOMING_BROKER_ADDRESS: blah
      EWMS_PILOT_QUEUE_OUTGOING_BROKER_ADDRESS: blah
      EWMS_PILOT_QUEUE_INCOMING: foo
      EWMS_PILOT_QUEUE_OUTGOING: bar
      EWMS_PILOT_TIMEOUT_QUEUE_WAIT_FOR_FIRST_MESSAGE: 1  # added to figure out https://github.com/WIPACrepo/wipac-dev-tools/pull/106, not needed but not doing any harm
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.sha }}  # lock to triggered commit (github.ref is dynamic)
          fetch-depth: 0  # setuptools-scm needs to access git tags
      - name: build docker image
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          docker build --tag ${{ env.DOCKER_IMAGE_NAME }} .
          docker images
      - name: test
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          set -ex
          
          docker run --rm \
              $(env | grep '^EWMS_' | awk '$0="--env "$0') \
              $(env | grep '^_EWMS_' | awk '$0="--env "$0') \
              ${{ env.DOCKER_IMAGE_NAME }} \
              2>&1 | tee -a test.out || exit_code=${PIPESTATUS[0]} 
          cat test.out
          
          # The intent of this test is to confirm that the pilot runs as a CL script
          #   without error. Real testing is done in 'integration-tests'. This "test"
          #   ends on the following error, which is relatively early in the pilot...
          
          expected="RuntimeError: Task image was not provided."
          if [[ $( tail -n 1 test.out ) == "$expected" ]]; then
              echo "passed! (iow, this is the correct error ^^^)"
          else
              echo "ERROR: the pilot did not fail as expected"
              exit 1
          fi

  unit-tests:
    needs: [ py-versions ]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        py3: ${{ fromJSON(needs.py-versions.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.sha }}  # lock to triggered commit (github.ref is dynamic)
          fetch-depth: 0  # setuptools-scm needs to access git tags
      - uses: actions/setup-python@v6
        with:
          python-version: ${{ matrix.py3 }}
      - name: pytest
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          pip install .[test]
          pytest -vvv --asyncio-mode=auto tests/unit

  integration-tests:
    needs: [ py-versions ]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        container_platform: [ docker, apptainer ]
        py3: ${{ fromJSON(needs.py-versions.outputs.matrix) }}
        broker_client: [ pulsar, rabbitmq, nats ]
    env:
      EWMS_PILOT_QUEUE_INCOMING_BROKER_TYPE: ${{ matrix.broker_client }}
      EWMS_PILOT_QUEUE_OUTGOING_BROKER_TYPE: ${{ matrix.broker_client }}
    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ github.sha }}  # lock to triggered commit (github.ref is dynamic)
          fetch-depth: 0  # setuptools-scm needs to access git tags
      - uses: actions/setup-python@v6
        with:
          python-version: ${{ matrix.py3 }}

      - if: ${{ matrix.broker_client == 'rabbitmq' }}
        name: "rabbitmq only: jlumbroso/free-disk-space@main"
        uses: jlumbroso/free-disk-space@main
        with:
          android: false  # this is a LOT of space, so it takes longer to remove
          docker-images: false  # we may actually need this one

      - if: ${{ matrix.container_platform == 'apptainer' }}
        name: "apptainer only: install apptainer"
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          curl -fsSL "$CI_SCRIPT_URL_INSTALL_APPTAINER" -o install-apptainer.sh && chmod +x install-apptainer.sh
          ./install-apptainer.sh

      - name: build docker image
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          docker build --tag ${{ env.DOCKER_IMAGE_NAME }} \
              --build-arg="PYTHON=${{ matrix.py3 }}" \
              --build-arg="FLAVOR=${{ matrix.broker_client }},test" \
              --build-arg="CONTAINER_PLATFORM=${{ matrix.container_platform }}" \
              .
          docker images

      - name: "mkdir $EWMS_PILOT_DATA_DIR_PARENT_PATH_ON_HOST"
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          dir="$(pwd)/blah"
          echo "EWMS_PILOT_DATA_DIR_PARENT_PATH_ON_HOST=$dir" >> $GITHUB_ENV
          mkdir $dir

      - name: "pre-pull images for testing"
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          set -x
          mkdir apptainer-prebuilds/
          
          retry_command_if_255() {
              # some logic to get around docker hub's rate limiting
              local command="$1"
              max_retries=5
              for ((i=1; i<=max_retries; i++)); do
                  eval "$command"
                  exit_code=$?
                  if [[ $exit_code -eq 0 ]]; then
                      break
                  elif [[ $exit_code -eq 255 ]]; then
                      # docker hub rate limiting
                      echo "::warning::Command failed with exit code 255. Retry $i/$max_retries..."
                  else
                      exit $exit_code
                  fi
                  # Wait before retrying
                  sleep $((30*$i))  # 30, 60, 90, ... 
              done
          }
          
          if [[ "${{ matrix.container_platform }}" == 'docker' ]]; then
              retry_command_if_255 "docker pull python:alpine"
          elif [[ "${{ matrix.container_platform }}" == "apptainer" ]]; then
              cd apptainer-prebuilds/
              # building as a sandbox (unpacked dir) allows apptainer-in-apptainer
              retry_command_if_255 "apptainer build --sandbox python_alpine_sandbox/ docker://python:alpine"
              # pilot converts .sif to apptainer dir -- only 1 test uses this
              retry_command_if_255 "apptainer build python_alpine.sif docker://python:alpine"
          else
              exit 2  # unknown container_platform
          fi

      - if: ${{ matrix.container_platform == 'apptainer' }}
        name: "apptainer only: build apptainer image"
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          docker images
          apptainer build $(basename ${{ env.DOCKER_IMAGE_NAME }}).sif docker-daemon://${{ env.DOCKER_IMAGE_NAME }}:latest
          ls -lh $(basename ${{ env.DOCKER_IMAGE_NAME }}).sif

      - name: get list of pytest tests
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          pip install .[test]  # for the for-loop below
          pytest --collect-only -q --disable-warnings tests/integration/ | head -n -2 > $SORTED_LIST_OF_TESTS_FILE
          cat $SORTED_LIST_OF_TESTS_FILE

      - if: ${{ matrix.container_platform == 'docker' }}
        name: "docker only: get docker-outside-of-docker helper script"
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          curl -fsSL "$CI_SCRIPT_URL_DOOD_RUN" -o "run-dood.sh"
          chmod +x "run-dood.sh"

      - name: Integrate
        timeout-minutes: ${{ matrix.broker_client == 'rabbitmq' && 20  ||  15  }}  # adjust if fails, remember this is only time for *this* step
        run: |
          # set -euo pipefail
          echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          set -x
          
          # step 1: CREATE DOCKER NETWORK
          if [[ "${{ matrix.container_platform }}" == "docker" ]]; then
              docker network create "$DOOD_NETWORK"
          fi
          
          # step 2: START MQ BROKER — this is always in docker container, even in 'apptainer' tests
          if [[ "${{ matrix.container_platform }}" == 'docker' ]]; then
              # USE THE DOCKER NETWORK CREATED IN PREVIOUS STEP
              source ./tests/integration/run-broker.sh "${{ matrix.broker_client }}" $BROKER_CONTAINER_NAME "--net=$DOOD_NETWORK"
              export EWMS_PILOT_QUEUE_INCOMING_BROKER_ADDRESS="$BROKER_CONTAINER_NAME"
              export EWMS_PILOT_QUEUE_OUTGOING_BROKER_ADDRESS="$BROKER_CONTAINER_NAME"
          elif [[ "${{ matrix.container_platform }}" == "apptainer" ]]; then
              # USE THE HOST NETWORK SINCE APPTAINER DOESN'T HAVE AS ISOLATED NETWORKING AS DOCKER DOES 
              source ./tests/integration/run-broker.sh "${{ matrix.broker_client }}" $BROKER_CONTAINER_NAME "--network=host"
              export EWMS_PILOT_QUEUE_INCOMING_BROKER_ADDRESS="localhost"  # localhost b/c using --network=host
              export EWMS_PILOT_QUEUE_OUTGOING_BROKER_ADDRESS="localhost"  # localhost b/c using --network=host
          else
              echo "::error::unknown container_platform: ${{ matrix.container_platform }}"
              exit 2
          fi
          docker ps
          
          # step 3: make external directories — used in like 1 test
          export CI_CVMFS_DIR="$(pwd)/cvmfs"
          export EWMS_PILOT_EXTERNAL_DIRECTORIES="/cvmfs/dummy-1/dir-A,/cvmfs/dummy-2/dir-B"
          mkdir -p "$CI_CVMFS_DIR/dummy-1/dir-A"
          echo "alpha" > $(pwd)/cvmfs/dummy-1/dir-A/file.txt
          mkdir -p "$CI_CVMFS_DIR/dummy-2/dir-B"
          echo "beta" > $(pwd)/cvmfs/dummy-2/dir-B/file.txt

          # step 4: RUN!
          # -- iterate each test, starting each in its own container
          set +x
          echo "--------------------------------------------------------------"
          echo "running tests..."
          cat $SORTED_LIST_OF_TESTS_FILE
          test_offset_delay=5
          pidlist=""
          i=0
          while read test; do
              echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
              echo "starting test $test (in background)"
              echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
          
              # NOTE: re 'sleep N && ...': this allows all tests to be submitted in bulk, 
              #   then waited for in order, PLUS it has a built-in delay to not overwhelm
              #   the broker. This way (as opposed to sleep between loop iterations), we 
              #   can stop all the tests if one fails early on (like pytest --exit-first).
          
              if [[ "${{ matrix.container_platform }}" == 'docker' ]]; then
          
                  # subshell so we can change env vars!
                  (
                      sleep "$(($i*$test_offset_delay))"  # sleep first
          
                      export DOOD_OUTER_IMAGE="${{ env.DOCKER_IMAGE_NAME }}"
                      if [[ -z "${DOOD_NETWORK:-}" ]]; then
                          echo "::error::DOOD_NETWORK must be set." 
                          exit 1
                      fi
                      export DOOD_BIND_RO_DIRS="\
                          $(pwd)/cvmfs/dummy-1/dir-A \
                          $(pwd)/cvmfs/dummy-2/dir-B \
                          $(realpath ${{ github.workspace }}/$(dirname $test)) \
                          "
                      export DOOD_BIND_RW_DIRS="$EWMS_PILOT_DATA_DIR_PARENT_PATH_ON_HOST"
                      export DOOD_FORWARD_ENV_PREFIXES="EWMS_ _EWMS_"
                      export CI_TEST_ALPINE_PYTHON_IMAGE="python:alpine"
                      export DOOD_FORWARD_ENV_VARS="CI_TEST_ALPINE_PYTHON_IMAGE CI CI_CVMFS_DIR"
                      export DOOD_OUTER_CMD="pytest -vvv --asyncio-mode=auto -s $(realpath ${{ github.workspace }})/$test"
          
                      ./run-dood.sh
                  ) >> $(basename $test).test.out 2>&1 & pidlist="$pidlist $!"
                  # 2>&1   # -- uncomment to debug
                  # exit 5 # -- uncomment to debug
          
              elif [[ "${{ matrix.container_platform }}" == "apptainer" ]]; then
          
                  # NOTE: we want to mimic how htcondor launches apptainer-enabled EPs
          
                  set -x  # lets see the command
                  temp_dir=$(mktemp -d)
                  # '--containall --writable-tmpfs --no-eval' gets us close to docker functionality
                  # '--workdir' allows using host disk instead of memory
                  sleep "$(($i*$test_offset_delay))" && apptainer run \
                      --containall --writable-tmpfs --no-eval \
                      --mount type=bind,source=$(pwd)/apptainer-prebuilds,target=/apptainer-prebuilds/ \
                      --mount type=bind,source=$(pwd)/cvmfs/dummy-1/dir-A,target=/cvmfs/dummy-1/dir-A,readonly \
                      --mount type=bind,source=$(pwd)/cvmfs/dummy-2/dir-B,target=/cvmfs/dummy-2/dir-B,readonly \
                      --mount type=bind,source="$(realpath ${{ github.workspace }}/$(dirname $test))",target="/app/$(dirname $test)",readonly \
                      $(env | grep '^EWMS_' | awk '$0="--env "$0') \
                      $(env | grep '^_EWMS_' | awk '$0="--env "$0') \
                      --env CI_TEST_ALPINE_PYTHON_IMAGE="/apptainer-prebuilds/python_alpine_sandbox/" \
                      --env CI_TEST_ALPINE_PYTHON_IMAGE_APPTAINER_SIF="/apptainer-prebuilds/python_alpine.sif" \
                      --env CI_TEST_ALPINE_PYTHON_IMAGE_APPTAINER_FROM_DOCKER="python:alpine" \
                      --env CI_CVMFS_DIR \
                      --env CI \
                      --workdir "$temp_dir" -B "$temp_dir" \
                      $(basename ${{ env.DOCKER_IMAGE_NAME }}).sif \
                      pytest -vvv --asyncio-mode=auto -s /app/$test \
                      >> $(basename $test).test.out 2>&1 & pidlist="$pidlist $!"
                      # 2>&1   # -- uncomment to debug
                      # exit 5 # -- uncomment to debug
                  set +x
          
              else
                  echo "::error::unknown container_platform: ${{ matrix.container_platform }}"
                  exit 2
              fi
          
              sleep .1  # little sleep to help logs
              i=$((i+1))
          done < $SORTED_LIST_OF_TESTS_FILE
          
          # step 5: wait for tests to finish
          # -- https://stackoverflow.com/a/32604828/13156561
          sleep 3  # short sleep to help logs
          for pid in $pidlist; do
              date --rfc-3339=seconds
              echo "waiting for $pid..."
              if ! wait -n $pid; then
                  echo "::error::test(s) failed (ctrl+f $pid to match)"
                  sleep 5  # may need to wait for output files to be written
                  kill $pidlist 2>/dev/null
                  exit 1
              fi
              echo "-> PASSED"
          done

      - name: "if pytest failed, dump first failure"
        if: always()
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          file=$(grep -l -m 1 "= FAILURES =" *.test.out 2>/dev/null | head -1 || true)
          if [[ -n "$file" ]]; then
              cat "$file"
              echo "::error::^^^^ this is the pytest out file -- this step exited with 1 because this *pytest* failed -- the ci step is okay"
              exit 1
          else
              echo "::warning::pytest failure not found -- either all tests passed, or a test container failed before pytesting"
          fi

      - name: pytest container outputs
        if: always()
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          sleep 15  # sleep a bit more in case there are additional failures we want to dig for
          cat $SORTED_LIST_OF_TESTS_FILE
          while read test; do
              echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
              echo $test
              echo "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
              if [ -f $(basename $test).test.out ]; then
                  cat $(basename $test).test.out
              else
                  echo "::warning::output file does not exist, test may not have be started -- look at above test logs"
              fi
          done < $SORTED_LIST_OF_TESTS_FILE

      - name: broker output
        if: always()
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          set -x
          cat ./broker.out
          if [ -n "$(ls -A ./broker_logs/ 2>/dev/null)" ]; then
            ls ./broker_logs/
            more ./broker_logs/* | cat  # cats with filenames (delimited by :::::::)
          fi

      - name: broker docker logs
        if: always()
        run: |
          set -euo pipefail; echo "now: $(date -u +"%Y-%m-%dT%H:%M:%S.%3N")"
          docker logs $BROKER_CONTAINER_NAME || true


  #############################################################################
  # GITHUB & PYPI RELEASE
  #############################################################################

  tag-and-release:
    # only run on main/default
    if: format('refs/heads/{0}', github.event.repository.default_branch) == github.ref
    needs: [
      py-versions,
      flake8,
      mypy,
      py-setup,
      py-dependencies,
      test-build-docker,
      integration-tests,
      unit-tests,
      vanilla-run
    ]
    uses: WIPACrepo/wipac-dev-workflows/.github/workflows/tag-and-release.yml@v1.20
    permissions: # for GITHUB_TOKEN
      contents: write
    secrets:
      # need this because image publish is triggered on tag
      TOKEN: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
    with:
      project-type: python
      python-version: "${{ fromJSON(needs.py-versions.outputs.matrix)[0] }}"
      release-artifacts: |
        py-dependencies-logs
